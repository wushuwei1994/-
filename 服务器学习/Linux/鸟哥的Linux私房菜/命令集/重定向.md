## 重定向 ##

#### 标准输入、输出和错误 ####

与 Unix 主题“任何东西都是一个文件”保持一致，程序，比方说 ls，实际上把他们的运行结果
输送到一个叫做标准输出的特殊文件（经常用 stdout 表示），而它们的状态信息则送到另一个叫做标准错误的文件（stderr）。默认情况下，标准输出和标准错误都连接到屏幕，而不是
保存到磁盘文件。除此之外，许多程序从一个叫做标准输入（stdin）的设备得到输入，默认情况下，标准输入连接到键盘。

I/O 重定向允许我们更改输出地点和输入来源。一般地，输出送到屏幕，输入来自键盘，
但是通过 I/O 重定向，我们可以做出改变。

#### 重定向标准输出 ####

I/O 重定向允许我们来重定义标准输出的地点。我们使用 “>” 重定向符后接文件名来重定向标准输出到除屏幕以外的另一个文件。为什么我们要这样做呢？因为有时候把一个命令的运行结果存储到一个文件很有用处。例如，我们可以告诉 shell 把 ls 命令的运行结果输送到文件 ls-output.txt 中去，由文件代替屏幕。

```
ex:
[root@iZwz9310a34vdxby0lza7tZ ~]# ls /usr/app > ls-output.txt
[root@iZwz9310a34vdxby0lza7tZ ~]# ls
ls-output.txt
```

**">"重定向符只重定向标准输出，而不会重定向标准错误。**

```
ex:
[root@iZwz9310a34vdxby0lza7tZ ~]# ls a > new-output.txt
ls: cannot access a: No such file or directory
[root@iZwz9310a34vdxby0lza7tZ ~]# ls -l
total 4
-rw-r--r-- 1 root root 53 Jun 27 09:34 ls-output.txt
-rw-r--r-- 1 root root  0 Jun 27 09:41 new-output.txt
ps:
文件长度为零！这是因为，当我们使用 “>” 重定向符来重定向输出结果时，目标文件总是从开头被重写。 因为我们 ls 命令没有产生运行结果，只有错误信息，重定向操作开始重写文件，然后 由于错误而停止，导致文件内容删除。
```

我们需要删除一个文件内容（或者创建一个新的空文件），可以使用这样的技巧：

```
//简单地使用重定向符，没有命令在它之前，这会删除一个已存在文件的内容或是 创建一个新的空文件。
[root@iZwz9310a34vdxby0lza7tZ ~]# > empty.txt 
```

使用”>>“操作符，将导致输出结果添加到文件内容之后。如果文件不存在，文件会被创建，就如使用了”>”操作符。

```
[root@iZwz9310a34vdxby0lza7tZ ~]# ls -l
total 1
-rw-r--r-- 1 root root 161 Jun 27 09:49 ls-output.txt
[root@iZwz9310a34vdxby0lza7tZ ~]# ls -l >> ls-output.txt
[root@iZwz9310a34vdxby0lza7tZ ~]# ls -l
total 1
-rw-r--r-- 1 root root 328 Jun 27 09:49 ls-output.txt
```

#### 重定向标准错误 ####

重定向标准错误缺乏专用的重定向操作符。为了重定向标准错误，我们必须参考其文件描述符。一个程序可以在几个编号的文件流中的任一个上产生输出。虽然我们已经将这些文件流的前三个称作标准输入、输出和错误，shell 内部分别将其称为文件描述符0、1和2。shell 使用文件描述符提供了一种表示法来重定向文件。因为标准错误和文件描述符2一样，我们用这种
表示法来重定向标准错误:

```
ex:
//文件描述符”2”，紧挨着放在重定向操作符之前，来执行重定向标准错误到文件 ls-error.txt 任务
[root@iZwz9310a34vdxby0lza7tZ ~]# ls a 2>ls-error.txt
```

#### 重定向标准输出和错误到同一个文件 ####

- 方法一(传统的方法，旧版本shell中也有效):

```
ex:
[root@iZwz9310a34vdxby0lza7tZ ~]# ls -l a > ls-output.txt 2>&1
//首先重定向标准输出到文件 ls-output.txt，然后 重定向文件描述符2（标准错误）到文件描述符1（标准输出）使用表示法2>&1。
```

注意重定向的顺序安排非常重要。标准错误的重定向必须总是出现在标准输出重定向之后，要不然它不起作用。上面的例子，重定向标准错误到文件 ls-output.txt，但是如果命令顺序改为：```2>&1 >ls-output.txt```，则标准错误定向到屏幕。

- 方法二：使用一个表示法 &> 来重定向标准输出和错误到文件

```
ex:
[root@iZwz9310a34vdxby0lza7tZ ~]# ls a &> ls-output.txt
```

#### 处理不需要的输出 ####

我们不想要一个命令的输出结果，只想把它们扔掉。这种情况尤其适用于错误和状态信息。系统通过重定向输出结果到一个叫做”/dev/null”的特殊文件，为我们提供了解决问题的方法。这个文件是系统设备，叫做位存储桶，它可以接受输入，并且对输入不做任何处理。为了隐瞒命令错误信息，我们这样做：

```
[root@iZwz9310a34vdxby0lza7tZ ~]# ls a 2> /dev/null
```

#### cat - 连接文件 ####

cat 命令读取一个或多个文件，然后复制它们到标准输出。就像这样：

```
cat [file]
ex:[root@iZwz9310a34vdxby0lza7tZ ~]# ls /usr > ls-output.txt
[root@iZwz9310a34vdxby0lza7tZ ~]# cat ls-output.txt 
app
bin
...
```

cat 经常被用来显示简短的文本文件。因为 cat 可以接受不只一个文件作为参数，所以它也可以用来把文件连接在一起。比方说我们下载了一个大型文件，这个文件被分离成多个部分（USENET 中的多媒体文件经常以这种方式分离），我们想把它们连起来。我们能用这个命令把它们连接起来：

```
//因为通配符总是以有序的方式展开，所以这些参数会以正确顺序安排。
cat movie.mpeg.0* > movie.mpeg
```

如果 cat 没有给出任何参数，它会从标准输入读入数据，又因为标准输入默认情况下连接到键盘，它正在等待我们输入数据！输入内容；下一步，输入 **Ctrl-d**（按住 Ctrl 键同时按下”d”），来告诉 cat，在标准输入中，它已经到达文件末尾（EOF）。由于没有文件名参数，cat 复制标准输入到标准输出，所以我们看到文本行重复出现。

重定向标准输入：```cat < a.txt```，把标准输入源从键盘改到文件a.txt，即**把一个文件作为标准输入源**。看到结果与cat [file]结果一样。

#### 管道线 ####

命令从标准输入读取数据并输送到标准输出的能力被一个称为管道线的 shell 特性所利用。使用管道操作符”|”（竖杠），一个命令的标准输出可以通过管道送至另一个命令的标准输入：

```
command1 | command2
ex:
//我们用 less 来一页一页地显示任何命令的输出，命令把它的运行结果输送到标准输出：
[root@iZwz9310a34vdxby0lza7tZ ~]# ls -l |less

```

这极其方便！使用这项技术，我们可以方便地检测会产生标准输出的任一命令的运行结果。

#### 过滤器 ####

管道线经常用来对数据完成复杂的操作。有可能会把几个命令放在一起组成一个管道线。通常，以这种方式使用的命令被称为过滤器。过滤器接受输入，以某种方式改变它，然后输出它。第一个我们想试验的过滤器是 sort。想象一下，我们想把目录/bin 和/usr/bin 中的可执行程序都联合在一起，再把它们排序，然后浏览执行结果：

```
[root@iZwz9310a34vdxby0lza7tZ ~]# ls /bin /usr/bin | sort |less
//ls 命令的输出结果由有序列表组成， 各自针对一个目录。通过在管道线中包含 sort，我们改变输出数据，从而产生一个 有序列表。
```

#### uniq - 报道或忽略重复行 ####

uniq 命令经常和 sort 命令结合在一起使用。uniq 从标准输入或单个文件名参数接受数据有序
列表（详情查看 uniq 手册页），默认情况下，从数据列表中删除任何重复行。所以，为了确信我们的列表中不包含重复句子（这是说，出现在目录/bin 和/usr/bin 中重名的程序），我们添加uniq 到我们的管道线中：

```
[root@iZwz9310a34vdxby0lza7tZ ~]# ls /bin /usr/bin | sort |uniq |less
//我们使用 uniq 从 sort 命令的输出结果中，来删除任何重复行。如果我们想看到 重复的数据列表，让 uniq 命令带上”-d”选项，就像这样：
$ ls /bin /usr/bin | sort | uniq -d | less
```

#### wc － 打印行数、字数和字节数 ####

wc（字计数）命令是用来显示文件所包含的行数、字数和字节数。例如：

```
[root@iZwz9310a34vdxby0lza7tZ ~]# wc a.txt ls-output.txt 
  3  20 106 a.txt
 14  14  74 ls-output.txt
 17  34 180 total
```

如果 wc 不带命令行参数，它接受标准输入。”-l”选项限制命令输出只能报道行数。添加 wc 到管道线来统计数据，是个很便利的方法。查看我们的有序列表中程序个数，我们可以这样做：

```
[me@linuxbox ~]$ ls /bin /usr/bin | sort | uniq | wc -l
2728
```

#### grep － 打印匹配行 ####

grep 命令,用来找到文件中的匹配文本。

```
grep pattern [file...]
```

当 grep 遇到一个文件中的匹配”模式”，它会打印出包含这个类型的行。grep 能够匹配的模式可以很复杂，但是现在我们把注意力集中在简单文本匹配上面。比如说，我们想在我们的程序列表中，找到文件名中包含单词”zip”的所有文件。这样一个搜索，可能让我们了解系统中的一些程序与文件压缩有关系。这样做：

```
[me@linuxbox ~]$ ls /bin /usr/bin | sort | uniq | grep zip
bunzip2
bzip2
gunzip
...
```

grep 有一些方便的选项：”-i”使得 grep 在执行搜索时忽略大小写（通常，搜索是大小写
敏感的），”-v”选项会告诉 grep 只打印不匹配的行。

#### head / tail － 打印文件开头部分/结尾部分 ####

有时候你不需要一个命令的所有输出。可能你只想要前几行或者后几行的输出内容。head 命令打印文件的前十行，而 tail 命令打印文件的后十行。默认情况下，两个命令都打印十行文本，但是可以通过”-n”选项来调整命令打印的行数。

```
[me@linuxbox ~]$ head -n 5 ls-output.txt
total 343496
...
[me@linuxbox ~]$ tail -n 5 ls-output.txt
...
```

它们也能用在管道线中：

```
[me@linuxbox ~]$ ls /usr/bin | tail -n 5
znew
...
```

tail 有一个选项允许你实时地浏览文件。当观察日志文件的进展时，这很有用，因为它们同时在被写入。在以下的例子里，我们要查看目录/var/log 里面的信息文件。在一些 Linux 发行版中，要求有超级用户权限才能阅读这些文件，因为文件/var/log/messages可能包含安全信息。

```
[me@linuxbox ~]$ tail -f /var/log/messages
Feb 8 13:40:05 twin4 dhclient: DHCPACK from 192.168.1.1
....
```

使用”-f”选项，tail 命令继续监测这个文件，当新的内容添加到文件后，它们会立即出现在屏幕上。这会一直继续下去直到你输入 Ctrl-c

#### tee － 从 Stdin 读取数据，并同时输出到 Stdout 和文件 ####

为了和我们的管道隐喻保持一致，Linux 提供了一个叫做 tee 的命令，这个命令制造了
一个”tee”，安装到我们的管道上。tee 程序从标准输入读入数据，并且同时复制数据
到标准输出（允许数据继续随着管道线流动）和一个或多个文件。当在某个中间处理
阶段来捕捉一个管道线的内容时，这很有帮助。这里，我们重复执行一个先前的例子，
这次包含 tee 命令，在 grep 过滤管道线的内容之前，来捕捉整个目录列表到文件 ls.txt：