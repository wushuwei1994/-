## 字符展开 ##

每当输入一个命令并按下 enter 键，bash 会在执行你的命令之前对输入的字符完成几个步骤的处理。我们已经见过几个例子：例如一个简单的字符序列”*”,对 shell 来说有着多么丰富的涵义。这背后的的过程叫做（字符）展开。通过展开，你输入的字符，在 shell 对它起作用之前，会展开成为别的字符。为了说明这一点，让我们看一看 echo 命令。echo 是一个 shell 内建命令，可以完成非常简单的任务。它将它的文本参数打印到标准输出中。

```
[root@iZwz9310a34vdxby0lza7tZ ~]# echo hello I am echo command
hello I am echo command
[root@iZwz9310a34vdxby0lza7tZ ~]# echo *
a.txt ls-output.txt
```

”\*“字符意味着匹配文件名中的任意字符，但在原先的讨论中我们并不知道 shell 是怎样实现这个功能的。简单的答案就是 shell 在 echo 命令被执行前把”\*“展开成了另外的东西（在这里，就是在当前工作目录下的文件名字）。当回车键被按下时，shell 在命令被执行前在命令行上自动展开任何符合条件的字符，所以 echo 命令的实际参数并不是”*“，而是它展开后的结果。知道了这个以后，我们就能明白 echo 的行为符合预期。

```
echo *
不会显示隐藏文件
[root@iZwz9310a34vdxby0lza7tZ ~]# echo .*
. .. .bash_history .bash_logout .bash_profile .bashrc .cshrc .lesshst .mysql_history .mysql_secret .oracle_jre_usage .rediscli_history .ssh .tcshrc .viminfo
名字”.” 和”..”也出现在结果中。由于它们是指当前工作目录和父目录，使用这种 模式可能会产生不正确的结果。
[root@iZwz9310a34vdxby0lza7tZ ~]# ls -d .[!.]?*
.bash_history  .bash_profile  .cshrc    .mysql_history  .oracle_jre_usage  .ssh     .viminfo
.bash_logout   .bashrc        .lesshst  .mysql_secret   .rediscli_history  .tcshrc
这种模式展开成所有以圆点开头，第二个字符不包含圆点，再包含至少一个字符， 并且这个字符之后紧接着任意多个字符的文件名。这个命令将正确列出大多数的隐藏文件 （但仍不能包含以多个圆点开头的文件名）。带有 -A 选项（“几乎所有”）的 ls 命令能够提供一份正确的隐藏文件清单：
ls -A
```

#### 波浪线展开####

波浪线字符(“~”)有特殊的含义。当它用在
一个单词的开头时，它会展开成指定用户的家目录名，如果没有指定用户名，则展开成当前用户的家目录：

#### 算术表达式展开 ####

shell 在展开中执行算数表达式。这允许我们把 shell 提示当作计算器来使用：

```
$((expression))
[root@iZwz9310a34vdxby0lza7tZ ~]# echo $((4+7))
11
```

算术表达式只支持整数（全部是数字，不带小数点），但是能执行很多不同的操作:+(加)、-(减)、*(乘)、/(除)、%(求余)、**(取幂)

```
[root@iZwz9310a34vdxby0lza7tZ ~]# echo $((5**2*3))
75
[root@iZwz9310a34vdxby0lza7tZ ~]# echo $(($((5**2))*3))
75
```

#### 花括号展开 ####

```
[me@linuxbox ~]$ echo Front-{A,B,C}-Back
Front-A-Back Front-B-Back Front-C-Back

花括号展开模式可能包含一个开头部分叫做报头，一个结尾部分叫做附言。花括号表达式本身可 能包含一个由逗号分开的字符串列表，或者一系列的整数，或者单个的字符串。这种模式不能 嵌入空白字符。这个例题使用了一系列整数：
[me@linuxbox ~]$ echo Number_{1..5}
Number_1  Number_2  Number_3  Number_4  Number_5
[me@linuxbox ~]$ echo {Z..A}
Z Y X W V U T S R Q P O N M L K J I H G F E D C B A

花括号展开可以嵌套：
[me@linuxbox ~]$ echo a{A{1,2},B{3,4}}b
aA1b aA2b aB3b aB4b

那么这对什么有好处呢？最常见的应用是，创建一系列的文件或目录列表。例如， 如果我们是摄影师，有大量的相片。我们想把这些相片按年月先后组织起来。首先， 我们要创建一系列以数值”年－月”形式命名的目录。通过这种方式，可以使目录名按照 年代顺序排列。我们可以手动键入整个目录列表，但是工作量太大了，并且易于出错。 反之，我们可以这样做：
root@iZwz9310a34vdxby0lza7tZ ~]# mkdir {2016..2017}-0{1..9} {2016..2017}-{10..12}
[root@iZwz9310a34vdxby0lza7tZ ~]# ls
2016-01  2016-03  2016-05  2016-07  2016-09  2016-11  2017-01  2017-03  2017-05  2017-07  2017-09  2017-11  a.txt
2016-02  2016-04  2016-06  2016-08  2016-10  2016-12  2017-02  2017-04  2017-06  2017-08  2017-10  2017-12  ls-output.txt
```

#### 参数展开 ####

这个特性在 shell 脚本中比直接在命令行中更有用。它的许多功能和系统存储小块数据，并给每块数据命名的能力有关系。许多像这样的小块数据，更恰当的称呼应该是变量，可供你方便地检查它们。例如，叫做”USER”的变量包含你的用户名。可以这样做来调用参数，并查看 USER 中的内容，：

```
[root@iZwz9310a34vdxby0lza7tZ ~]# echo $USER
root
要查看有效的变量列表
[root@iZwz9310a34vdxby0lza7tZ ~]# printenv | less
```

你可能注意到在其它展开类型中，如果你误输入一个模式，展开就不会发生。这时echo 命令只简单地显示误键入的模式。但在参数展开中，如果你拼写错了一个变量名，展开仍然会进行，只是展开的结果是一个空字符串：

#### 命令替换 ####

命令替换允许我们把一个命令的输出作为一个展开模式来使用：

```
[root@iZwz9310a34vdxby0lza7tZ ~]# echo $(ls)
2016-01 2016-02 2016-03 2016-04 2016-05 2016-06 2016-07 2016-08 2016-09 2016-10 2016-11 2016-12 2017-01 2017-02 2017-03 2017-04 2017-05 2017-06 2017-07 2017-08 2017-09 2017-10 2017-11 2017-12 a.txt ls-output.txt

[root@iZwz9310a34vdxby0lza7tZ ~]# ls -l $(which cp)
-rwxr-xr-x 1 root root 122896 Jun 25  2014 /bin/cp

[me@linuxbox ~]$ file $(ls /usr/bin/* | grep zip)
```

在旧版 shell 程序中，有另一种语法也支持命令替换，bash 也支持这种语法。它使用倒引号来代替美元符号和括号：

```
[root@iZwz9310a34vdxby0lza7tZ ~]# ls -l `which cp`
-rwxr-xr-x 1 root root 122896 Jun 25  2014 /bin/cp
```

#### 引用 ####

```
[me@linuxbox ~]$ echo this is a    test
this is a test
shell 利用单词分割删除掉 echo 命令的参数列表中多余的空格。

[me@linuxbox ~]$ echo The total is $100.00
The total is 00.00
参数展开把 $1 的值替换为一个空字符串，因为 1 是没有定义的变量。shell 提供了一种 叫做引用的机制，来有选择地禁止不需要的展开。
```

#### 双引号 ####

我们将要看一下引用的第一种类型，双引号。如果你把文本放在双引号中，
shell 使用的特殊字符，都失去它们的特殊含义，被当作普通字符来看待。
有几个例外： $（命令替换），\ (反斜杠），和 `（倒引号）。这意味着单词分割、路径名展开、波浪线展开和花括号展开都将失效，然而参数展开、算术展开和命令替换仍然执行。使用双引号，我们可以处理包含空格的文件名。比方说我们是不幸的名为 *two words.txt* 文件的受害者。如果我们试图在命令行中使用这个文件，单词分割机制会导致这个文件名被看作两个独自的参数，而不是所期望的单个参数：

在双引号中，参数展开、算术表达式展开和命令替换仍然有效：

```
[me@linuxbox ~]$ echo "$USER $((2+2)) $(cal)"
me 4    February 2008
Su Mo Tu We Th Fr Sa
....
```

在默认情况下，单词分割机制会在单词中寻找空格，制表符，和换行符，并把它们看作单词之间的界定符。这意味着无引用的空格，制表符和换行符都不是文本的一部分，它们只作为分隔符使用。由于它们把单词分为不同的参数，所以在上面的例子中，命令行包含一个带有四个不同参数的命令。

单词分割被禁止，内嵌的空格也不会被当作界定符，它们成为参数的一部分。
一旦加上双引号，我们的命令行就包含一个带有一个参数的命令。事实上，单词分割机制把换行符看作界定符，对命令替换产生了一个虽然微妙但有趣的影响。考虑下面的例子：

```
[me@linuxbox ~]$ echo $(cal)
February 2008 Su Mo Tu We Th Fr Sa 1 2 3 4 5 6 7 8 9 10 11 12 13 14
15 16 17 18 19 20 21 22 23 24 25 26 27 28 29
[me@linuxbox ~]$ echo "$(cal)"
February 2008
....
在第一个实例中，没有引用的命令替换导致命令行包含38个参数。在第二个例子中， 命令行只有一个参数，参数中包括嵌入的空格和换行符。
```

#### 单引号 ####

如果需要禁止所有的展开，我们要使用单引号。以下例子是无引用，双引号，和单引号的比较结果：

```
[me@linuxbox ~]$ echo text ~/*.txt {a,b} $(echo foo) $((2+2)) $USER
text /home/me/ls-output.txt a b foo 4 me
[me@linuxbox ~]$ echo "text ~/*.txt {a,b} $(echo foo) $((2+2)) $USER"
text ~/*.txt   {a,b} foo 4 me
[me@linuxbox ~]$ echo 'text ~/*.txt {a,b} $(echo foo) $((2+2)) $USER'
text ~/*.txt  {a,b} $(echo foo) $((2+2)) $USER
```

#### 转义字符 ####

有时候我们只想引用单个字符。我们可以在字符之前加上一个反斜杠，在这里叫做转义字符。经常在双引号中使用转义字符，来有选择地阻止展开。

```
[me@linuxbox ~]$ echo "The balance for user $USER is: \$5.00"
The balance for user me is: $5.00
```

使用转义字符来消除文件名中一个字符的特殊含义，是很普遍的。例如，在文件名中可能使用一些对于 shell 来说有特殊含义的字符。这些字符包括”$”, “!”, “ “等字符。在文件名中包含特殊字符，你可以这样做：

```
[me@linuxbox ~]$ mv bad\&filename good_filename
```

为了允许反斜杠字符出现，输入”\“来转义。注意在单引号中，反斜杠失去它的特殊含义，它被看作普通字符。

> 反斜杠除了作为转义字符外，也可以构成一种表示法，来代表某种特殊字符，这些特殊字符叫做控制码。ASCII 编码表中前32个字符被用来把命令转输到电报机之类的设备。一些编码是众所周知的（制表符，退格符，换行符，和回车符），而其它一些编码就不熟悉了（空值，传输结束码，和确认）。
>
> | 转义序列 | 含义                     |
> | ---- | ---------------------- |
> | \a   | 响铃（”警告”－导致计算机嘟嘟响）      |
> | \b   | 退格符                    |
> | \n   | 新的一行。在类 Unix 系统中，产生换行。 |
> | \r   | 回车符                    |
> | \t   | 制表符                    |
>
> 上表列出了一些常见的反斜杠转义字符序列。这种利用反斜杠的表示法背后的思想来源于 C 编程语言，许多其它语言也采用了这种表示方法，包括 shell。
>
> echo 命令带上 ‘-e’ 选项，能够解释转义序列。你可以把转义序列放在 $' ' 里面。以下例子中，我们可以使用 sleep 命令创建一个简单的倒数计数器（ sleep 是一个简单的程序，它会等待指定的秒数，然后退出）：
>
> *sleep 10; echo -e "Time's up\a"*
>
> We could also do this:我们也可以这样做：
>
> *sleep 10; echo "Time's up" $'\a'*