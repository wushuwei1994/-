## 简单动态字符串 

Redis字符串没有直接使用C语言传统的字符串（以空字符结尾的字符数组）表示，而是构建了一种名为简单动态字符串（simple dynamic string，SDS）的抽象类型，并将SDS用作Redis的默认字符串表示。

####定义 
```c
struct sdshdr {
  //记录buf数组中已使用字节的数量，等于SDS所保存字符串的长度
  int len;
  
  //记录buf数组中未使用字节的数量
  int free;
  
  //字节数组，用于保存字符串
  char buf[];
}
```
SDS遵循C字符串以空字符串结尾的惯例，保存空字符的1字节空间不计算在SDS的len属性里面，并为空字符分配额外的1字节空间，以及添加空字符到字符串末尾等操作，都是由SDS函数自动完成。

#### SDS与C字符串的区别 
* **常数复杂度获取字符串长度** 
  C获取字符串的长度，需要遍历整个字符串，对遇到每个字符串进行计数，直到遇到代表字符串结尾的空字符为止，这个操作的复杂度为O(*N*)。 
  SDS只需访问len属性，即可获得字符串长度；设置和更新SDS长度由SDS的API自动完成。 
* **杜绝缓冲区溢出** 
  C在操作字符串（合并）的时候，可能由于未分配合适内存导致缓冲区溢出。 
  SDS在操作字符串（合并）的时候，会检查free未使用字节的大小，如果不满足需求，API会自动将SDS的空间扩展至执行修改需要的大小，然后才执行实际的修改操作。 
* **减少修改字符串时带来的内存重分配次数** 
  C在执行拼接操作需要内存重分配来扩展底层数组的空间大小；在截断操作需要通过内存重分配来释放字符串不再使用的那部分空间。内存分配涉及复杂的算法，并且可能需要执行系统调度，所以它通常是一个比较耗时的操作。 
  SDS通过未使用空间，实现了空间预分配和惰性空间释放两种优化策略。
  - 空间预分配（将连续增长N次字符串所需的内存重分配次数必定N次降低为最多N次）
    当SDS的API对一个SDS进行修改，并且需要对SDS进行空间扩展的时候，程序不仅会为SDS分配修改所必须的空间，还会为SDS分配额外的未使用空间。额外分配空间原则：1)SDS**修改之后**，长度小于1MB，则程序分配和len属性同样大小的未使用空间。2)SDS**修改之后**，长度大于等于1MB，则程序会分配1MB的未使用空间。
  - 惰性空间释放
    当字符串缩短时，程序并不立即使用内存重分配来回收缩短后多出来的字节，而是使用free属性将这些字节的数量记录起来，并等待将来使用。 
* **二进制安全** 
  C字符串中的字符必须符合某种编码，并且除了字符串的末尾之外，字符串里面不能包含空字符，这些限制使得C字符串只能保存文本数据，而不能保存像图片、音频、视频、压缩文件这样的二进制数据。 
  SDS API都会以处理二进制的方式来处理SDS存放在buf数组里的数据。所以我们将SDS的buf属性称为字节数组。 
* **兼容部分C字符串函数** 

#### SDS API


