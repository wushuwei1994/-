## Java位运算

#### 相关数据二进制表示

1. int 整型：32位，取值范围 -2^31~2^31-1，一共可以表示 2^32个整型数字 

2. 相关二进制：

   ```
   Integer.MAX_VALUE = 2147483647
   bit:Integer.MAX_VALUE = 111 1111 1111 1111 1111 1111 1111 1111 (31个1)
   bit:-1 = 11111111111111111111111111111111 （32个1）
   Integer.MAX_VALUE + 1 = -2147483648
   bit:Integer.MIN_VALUE = 10000000000000000000000000000000
   ```

3. 负数二进制表示：

   1)原码：按绝对值转成正数二进制数，高位再补1（符号位）

   2)反码：对该数的原码除符号位外各位取反

   3)补码：在反码基础上最后一位+1

   ```
   //示例
   // -1
   原码：10000000000000000000000000000001
   反码：11111111111111111111111111111110
   补码：11111111111111111111111111111111
   // - 2^31
   原码：10000000000000000000000000000000
   反码：11111111111111111111111111111111
   补码：10000000000000000000000000000000
   ```

#### 位逻辑运算 

##### &「与」 

运算规则：参与运算的数字，低位对齐，高位不足的补零，如果对应的二进制位同时为 1，那么计算结果才为 1，否则为 0。因此，任何数与 0 进行按位与运算，其结果都为 0。

```
100&0     //结果为0
1101&11   //结果为0001
```

#####  | 「或」

运算规则：参与运算的数字，低位对齐，高位不足的补零。如果对应的二进制位只要有一个为 1，那么结果就为 1；如果对应的二进制位都为 0，结果才为 0。

```
1011|0111 //结果为1111
```

#####  ^ 「异或」

运算规则：参与运算的数字，低位对齐，高位不足的补零，如果对应的二进制位相同（同时为 0 或同时为 1）时，结果为 0；如果对应的二进制位不相同，结果则为 1。

```
1011^0111 //结果为1100
```

 ##### ~「反」

运算规则：只对一个操作数进行运算，将操作数二进制中的 1 改为 0，0 改为 1。

```
~1 //结果为:-2
//思路：
//取反运算：11111111111111111111111111111110（此时为负数，补码形式）
//反码（反码转补码是+1，所以补码转反码为-1）：11111111111111111111111111111101
//原码（反码取反）：00000000000000000000000000000010
//负数的原码为负数的绝对值，所以结果为-2
```

#### 位移运算符

##### <<  左位移

运算规则：按二进制形式把所有的数字向左移动对应的位数，高位移出（舍弃），低位的空位补零（相当于乘2）

```
7<<1 //28
7<<2 //14
```

##### >> 右位移

运算规则：按二进制形式把所有的数字向右移动对应的位数，低位移出（舍弃），高位的空位补零（相当于除2）

```
7>>1 //3
7>>2 //1
```




